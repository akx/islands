TerrainGeometry = (xRes, yRes, data, dataWidth, dataHeight, heightScale=1 ) ->
	THREE.Geometry.call( this )

	sample = !(segX, segY) ->
		dataX = 0 | Math.round(segX / xRes * dataWidth)
		dataY = 0 | Math.round(segY / yRes * dataHeight)
		dataX = 0 >? dataX >? (dataWidth - 1)
		dataY = 0 >? dataY >? (dataHeight - 1)
		return data[dataY * dataWidth + dataX]

	vtxOff = !(segX, segY) ->
		return (0 | segY) << 16 + (0 | segX)

	vtxTable = {}

	for y from 0 to yRes
		for x from 0 to xRes
			z = sample(x, y) * heightScale
			vtxTable[vtxOff(x, y)] = @vertices.length
			@vertices.push(new THREE.Vector3(x, z, y))

	for y from 0 til yRes - 1
		for x from 0 til xRes - 1
			vo1 = vtxTable[vtxOff(x, y)]
			vo2 = vtxTable[vtxOff(x + 1, y)]
			vo3 = vtxTable[vtxOff(x + 1, y + 1)]
			vo4 = vtxTable[vtxOff(x, y + 1)]
			v1 = @vertices[vo1]
			v2 = @vertices[vo2]
			v3 = @vertices[vo3]
			v4 = @vertices[vo4]
			continue if v1.z < 0 or not (v1 and v2 and v3 and v4)
			#console.log v1, v2, v3, v4

			face = new THREE.Face3(vo1, vo2, vo4)
			face.normal = new THREE.Vector3(0, 1, 0)
			@faces.push(face)
			face = new THREE.Face3(vo2, vo3, vo4)
			face.normal = new THREE.Vector3(0, 1, 0)
			@faces.push(face)

	@computeCentroids()

TerrainGeometry.prototype = Object.create( THREE.Geometry.prototype );

class HeightmapThreeJS
	(@heightmap) ->
		WIDTH = 640
		HEIGHT = 480
		VIEW_ANGLE = 60
		ASPECT = WIDTH / HEIGHT
		@renderer = new THREE.WebGLRenderer({+antialias})
			&setClearColor(0xFFFFFF)
			&setSize(WIDTH, HEIGHT)
			document.body.appendChild(&domElement)
		@camera = new THREE.PerspectiveCamera(60, WIDTH / HEIGHT, 0.1, 1000)
		@pointLight = new THREE.PointLight(0xFFFFFF)
		@scene = new THREE.Scene()
			&add(@camera)
			&add(@pointLight)
			&add(new THREE.AxisHelper(10))
			&add(new THREE.GridHelper(100, 5))

	updateMesh: !->
		material = new THREE.MeshLambertMaterial({color: 0x5B8F50, shading: THREE.FlatShading, vertexColors: THREE.VertexColors, side: THREE.DoubleSide})
		geometry = new TerrainGeometry(32, 32, @heightmap.heightmapData, @heightmap.mapWidth, @heightmap.mapHeight, 0.1)
		geometry.verticesNeedUpdate = true
		plane = new THREE.Mesh(geometry, material)
		if @plane
			@scene.remove(@plane)
			@plane = null
		@plane = plane

	
	render: !->
		ang = +new Date() * -0.0005
		c = Math.cos(ang) * 50
		s = Math.sin(ang) * 50
		p = @camera.position = new THREE.Vector3(c, 50, s)
		@camera.lookAt(new THREE.Vector3(0, 0, 0))
		@pointLight.position <<< {x: p.x - 10, y: p.y, z: p.z - 10}
		@renderer.render(@scene, @camera)
