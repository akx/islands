const THREE = require('three')

class ThreePlaneWrapper
	(@heightmap, @resX, @resY, @heightScale=1) ->
		@geometry = new THREE.PlaneGeometry(100, 100, @resX, @resY)

	sample: (x, y) ->
		x /= @resX
		y /= @resY
		x *= @heightmap.mapWidth
		y *= @heightmap.mapHeight
		x = 0 | x
		y = 0 | y
		if x < 0 or x > @heightmap.mapWidth then return -1
		if y < 0 or y > @heightmap.mapHeight then return -1
		y = @heightmap.heightmapData[y * @heightmap.mapWidth + x] * @heightScale
		if y <= 0 then y = -1
		return y

	update: !->
		clampColor = !(a) ->
			return 0 if a < 0
			return 255 if a >= 255
			return (0 | a)

		for y from 0 til @resX
			for x from 0 til @resY
				z = @sample(x, y)
				o = y * (@resX + 1) + x
				@geometry.vertices[o].z = z

		max = 0
		for @geometry.vertices => max = max >? &z

		const faceIndices = <[a b c]>
		for face of @geometry.faces
			for vi from 0 til 3
				v = @geometry.vertices[face[faceIndices[vi]]]
				height = (v.z / max)
				r = g = b = 0 | (255 * height)

				color = new THREE.Color(clampColor(r) << 16 | clampColor(g) << 8 | clampColor(b))
				face.vertexColors[vi] = color

		@geometry.computeFaceNormals()
		@geometry.computeVertexNormals()			
		@geometry.verticesNeedUpdate = true
		@geometry.colorsNeedUpdate = true
		return @geometry




class HeightmapThreeJS
	(@heightmap) ->
		WIDTH = 640
		HEIGHT = 480
		VIEW_ANGLE = 60
		ASPECT = WIDTH / HEIGHT
		@renderer = new THREE.WebGLRenderer({+antialias})
			&setClearColor(0xFFFFFF)
			&setSize(WIDTH, HEIGHT)
			document.body.appendChild(&domElement)
		@camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, 0.1, 1000)
		@pointLight = new THREE.PointLight(0xFFFFFF)
		@sea = new THREE.Mesh(
			new THREE.PlaneGeometry(100, 100, 3, 3),
			new THREE.MeshLambertMaterial({color: 0x53BEFF})
		)
		@sea.rotation.x = Math.PI * -0.5

		@scene = new THREE.Scene()
			&add(@camera)
			&add(@pointLight)
			&add(@sea)
			&add(new THREE.AxisHelper(10))
			#&add(new THREE.GridHelper(100, 5))


	updateMesh: !->
		material = new THREE.MeshPhongMaterial({color: 0xFFFFFF, vertexColors: THREE.VertexColors})
		tpw = new ThreePlaneWrapper(@heightmap, 64, 64, 0.1)
		geometry = tpw.update()
		plane = new THREE.Mesh(geometry, material)
		if @plane
			@scene.remove(@plane)
			@plane = null
		@plane = plane
		@plane.rotation.x = Math.PI * -0.5
		@scene.add(plane)


	
	render: !->
		ang = +new Date() * -0.0005
		c = Math.cos(ang) * 50
		s = Math.sin(ang) * 50
		@camera.position.x = c
		@camera.position.y = 50
		@camera.position.z = s
		@camera.lookAt(@scene.position)
		@pointLight.position <<< {x: 15, y: 60, z: 15}
		@renderer.render(@scene, @camera)

module.exports = HeightmapThreeJS
