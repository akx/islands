lerp = (a, b, alpha) -> (b * alpha + a * (1 - alpha))

getDistance = (x1, y1, x2, y2) ->
	dx2 = (x2 - x1) * (x2 - x1)
	dy2 = (y2 - y1) * (y2 - y1)
	return Math.sqrt(dx2 + dy2)

getSquaredDistance = (x1, y1, x2, y2) ->
	dx2 = (x2 - x1) * (x2 - x1)
	dy2 = (y2 - y1) * (y2 - y1)
	return (dx2 + dy2)

distToSegmentSquared = (p, v, w) ->
	# Return the distance from point p to line segment (v..w)
	l2 = getSquaredDistance(v[0], v[1], w[0], w[1])
	if l2 <= 0 then return getSquaredDistance(p[0], p[1], v[0], v[1])
	t = ((p[0] - v[0]) * (w[0] - v[0]) + (p[1] - v[1]) * (w[1] - v[1])) / l2
	if t <= 0 then return getSquaredDistance(p[0], p[1], v[0], v[1])
	if t >= 1 then return getSquaredDistance(p[0], p[1], w[0], w[1])
	return getSquaredDistance p[0], p[1], v[0] + t * (w[0] - v[0]), v[1] + t * (w[1] - v[1])

distToSegment = (p, v, w) -> Math.sqrt(distToSegmentSquared(p, v, w))

closestPointOnSegment = (p, v, w) ->
	l2 = getSquaredDistance(v[0], v[1], w[0], w[1])
	if l2 <= 0 then return p
	t = ((p[0] - v[0]) * (w[0] - v[0]) + (p[1] - v[1]) * (w[1] - v[1])) / l2
	if t <= 0 then return v
	if t >= 1 then return w
	return [
		v[0] + t * (w[0] - v[0]),
		v[1] + t * (w[1] - v[1])
	]

export lerp
export closestPointOnSegment
export distToSegment
export getDistance
export getSquaredDistance
