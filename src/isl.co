const debounce = require('lodash/debounce')
const dat = require('dat.gui/build/dat.gui.js')
const ClipperLib = require('clipper-lib')
const SVG = require('svg.js')
require('svg.filter.js')
ClipperLib.Error = (err) -> throw new Error(err)

const HeightmapThreeJS = require('./isl-three.co')

const PI2 = Math.PI * 2


rand = (a, b) -> a + Math.random() * (b - a)

class RC4Rand
	(seed) ->
		@s = (for x from 0 til 256 => x)
		@i = @j = 0
		if seed then @mix(seed)
	
	mix: !(seed) ->
		seed = "#seed"
		j = 0
		for i from 0 til @s.length
			ch = seed.charCodeAt(i % seed.length) & 0xFF
			j += @s[i] + ch
			j %= 256
			@_swap(i, j)

	_swap: !(i, j) -> [@s[j], @s[i]] = [@s[i], @s[j]]

	nextByte: !->
		@i = (@i + 1) % 256
		@j = (@j + @s[@i]) % 256
		@_swap(@i, @j)
		return @s[(@s[@i] + @s[@j]) % 256]

	nextFloat: !->
		const BYTES = 7
		output = 0
		for i from 0 til BYTES
			output = output * 256 + @nextByte()
		return output / (Math.pow(2, BYTES * 8) - 1)

	uniform: (a, b) ->
		if b < a then [a, b] = [b, a]
		return a + @nextFloat() * (b - a)
	
	uniformInt: (a, b) -> Math.floor(@uniform(a, b))

class RandomFarm
	(@seed) ->
	get: (name) -> new RC4Rand("#{@seed}+#{name}")


class Gradient
	(@resolution=512) -> @points = []; @bitmap = null
	addPoint: !(color, point) -> @points.push {color, point}
	getColor: !(point) ->
		if not @bitmap then @bitmap = @render() 
		if point < 0 then point = 0
		if point > 1 then point = 1
		offset = (0 | point * @bitmap.width) * 4
		data = @bitmap.data
		return "rgb(#{data[offset]}, #{data[offset+1]}, #{data[offset+2]})"

	render: !->
		canvas = document.createElement("canvas")
		canvas.width = @resolution
		canvas.height = 10
		ctx = canvas.getContext("2d")
		gradient = ctx.createLinearGradient(0, 0, canvas.width, 0)
		for {color, point} of @points
			gradient.addColorStop(point, color)
		ctx.fillStyle = gradient
		ctx.fillRect(0, 0, canvas.width, canvas.height)
		return ctx.getImageData(0, 0, canvas.width, canvas.height)

lerp = (a, b, alpha) -> (b * alpha + a * (1 - alpha))

getDistance = (x1, y1, x2, y2) ->
	dx2 = (x2 - x1) * (x2 - x1)
	dy2 = (y2 - y1) * (y2 - y1)
	return Math.sqrt(dx2 + dy2)

getSquaredDistance = (x1, y1, x2, y2) ->
	dx2 = (x2 - x1) * (x2 - x1)
	dy2 = (y2 - y1) * (y2 - y1)
	return (dx2 + dy2)

distToSegmentSquared = (p, v, w) ->
	# Return the distance from point p to line segment (v..w)
	l2 = getSquaredDistance(v[0], v[1], w[0], w[1])
	if l2 <= 0 then return getSquaredDistance(p[0], p[1], v[0], v[1])
	t = ((p[0] - v[0]) * (w[0] - v[0]) + (p[1] - v[1]) * (w[1] - v[1])) / l2
	if t <= 0 then return getSquaredDistance(p[0], p[1], v[0], v[1])
	if t >= 1 then return getSquaredDistance(p[0], p[1], w[0], w[1])
	return getSquaredDistance p[0], p[1], v[0] + t * (w[0] - v[0]), v[1] + t * (w[1] - v[1])

distToSegment = (p, v, w) -> Math.sqrt(distToSegmentSquared(p, v, w))

closestPointOnSegment = (p, v, w) ->
	l2 = getSquaredDistance(v[0], v[1], w[0], w[1])
	if l2 <= 0 then return p
	t = ((p[0] - v[0]) * (w[0] - v[0]) + (p[1] - v[1]) * (w[1] - v[1])) / l2
	if t <= 0 then return v
	if t >= 1 then return w
	return [
		v[0] + t * (w[0] - v[0]),
		v[1] + t * (w[1] - v[1])
	]


poly2clipper = (poly) ->
	subj_polygon = new ClipperLib.Path()
	for [x, y] of poly
		subj_polygon.push new ClipperLib.IntPoint(x, y)
	return subj_polygon

clipper2poly = (clipper) -> for (clipper || []) => [&X, &Y]

poly_op = (polys1, polys2, clipType) ->
	subj_polygons = new ClipperLib.Paths()
	for polys1 => subj_polygons.push poly2clipper(&)
	clip_polygons = new ClipperLib.Paths()
	for polys2 => clip_polygons.push poly2clipper(&)

	clipper = new ClipperLib.Clipper()
	clipper.AddPaths subj_polygons, ClipperLib.PolyType.ptSubject, true
	clipper.AddPaths clip_polygons, ClipperLib.PolyType.ptClip, true
	solution_polygons = new ClipperLib.Paths()
	fillType = ClipperLib.PolyFillType.pftPositive
	if not clipper.Execute(clipType, solution_polygons, fillType, fillType) then
		console.log "No success."
		return []
	else
		return (for solution_polygons => clipper2poly(&))

merge = (polys) ->
	polys2 = [].concat(polys)
	polys1 = [polys2.shift()]
	return poly_op(polys1, polys2, ClipperLib.ClipType.ctUnion)

cut = (polys1, polys2) -> poly_op(polys1, polys2, ClipperLib.ClipType.ctDifference)

outsetPoly = (poly, delta) ->
	joinType = ClipperLib.JoinType.jtMiter
	miterLimit = 0
	clipperOffset = new ClipperLib.ClipperOffset(miterLimit, 0)
	clipperOffset.AddPaths([poly2clipper(poly)], joinType, ClipperLib.EndType.etClosedPolygon)
	solution = new ClipperLib.Paths()
	clipperOffset.Execute(solution, delta)
	cleanedPaths = ClipperLib.JS.Clean(solution, 2.5)
	return (for cleanedPaths => clipper2poly(&))

makeRotator = (a) ->
	c = Math.cos(a)
	s = Math.sin(a)
	return (x, y) -> [x * c - y * s, x * s + y * c]


jitterPoly = (rng, poly, ix, iy) -> for [x, y] of poly => [x + rng.uniform(-ix, ix), y + rng.uniform(-iy, iy)]
offsetPoly = (poly, ix, iy) -> for [x, y] of poly => [x + ix, y + iy]

IntParam = (name, value, min=0, max=100) -> {name, value, min, max, type: "int"}
FloatParam = (name, value, min=0, max=1.0) -> {name, value, min, max, type: "float"}
BoolParam = (name, value) -> {name, value: !!value, type: "bool"}
StringParam = (name, value) -> {name, value: "#{value}", type: "string"}

class ParamGroup
	(@name, @params) ->

class ParamCollection
	-> @groups = []
	group: (name, params) -> @groups.push(new ParamGroup(name, params))
	initialize: ->
		params = {}
		for group of @groups
			for param of group.params
				params[param.name] = param.value
		return params

class HeightmapGenerator
	(@ig, @mapWidth, @mapHeight) ->
		@scaleX = @mapWidth / @ig.width
		@scaleY = @mapHeight / @ig.height

		#for document.querySelectorAll("canvas") => &parentNode.removeChild(&)

		@debugCanvas = document.createElement("canvas")
			&width = @mapWidth
			&height = @mapHeight
			@debugCtx = &getContext("2d")
			&style.border = "1px solid red"
			&style.width = "500px"
			&style.height = "500px"
			document.body.appendChild(&)
		
		@scratchCanvas = document.createElement("canvas")
			&width = @mapWidth
			&height = @mapHeight
			@scratchCtx = &getContext("2d")
			&style.border = "1px solid black"

			# document.body.appendChild(&)

		@heightmapData = new Float32Array(mapWidth * mapHeight)

		@segments = @_generateSegments()
		console.log "#{@segments.length} segments."

	_generateSegments: !->
		segments = []
		for layer of @ig.layers
			height = layer.height
			for a from 0 til layer.length
				b = (a + 1) % layer.length
				pa = [layer[a][0] * @scaleX, layer[a][1] * @scaleY]
				pb = [layer[b][0] * @scaleX, layer[b][1] * @scaleY]
				segments.push ([pa, pb] <<< {height})
		return segments
		
	_updateDebugCanvas: !->
		max = 0
		for @heightmapData => max = max >? &
		@debugCtx
			&fillStyle = "purple"
			&fillRect(0, 0, @mapWidth, @mapHeight)
			data = &getImageData(0, 0, @mapWidth, @mapHeight)
		for height, i of @heightmapData
			if height > 0 then
				color = 0 | (height / max * 255.0)
				data.data[i * 4 + 0] = color
				data.data[i * 4 + 1] = color
				data.data[i * 4 + 2] = color
				data.data[i * 4 + 3] = 255
		@debugCtx.putImageData(data, 0, 0)
		@debugCtx.fillStyle = "white"
		@debugCtx.fillText("max = #{0|max}", 3, @mapHeight - 3)

	_determineBaseRegion: !->
		sc = @scratchCtx
		sc.fillStyle = "black"
		sc.fillRect(0, 0, @mapWidth, @mapHeight)
		sc.fillStyle = 'red'
		for layer of @ig.layers
			continue if layer.height > 0
			sc.beginPath()
			for [x, y], i of layer
				x *= @scaleX
				y *= @scaleY
				if i == 0 then
					sc.moveTo(x, y)
				else
					sc.lineTo(x, y)
			sc.closePath()
			sc.fill()

		# Un-antialias the polygon...
		data = sc.getImageData(0, 0, @mapWidth, @mapHeight)
		for i from 0 til @mapWidth * @mapHeight
			off = i * 4
			if data.data[off] >= 250
				data.data[off++] = 255
			else
				data.data[off++] = 0
			data.data[off++] = 0
			data.data[off++] = 0
			data.data[off++] = 255
		sc.putImageData(data, 0, 0)



	startGenerate: !->
		@_determineBaseRegion()
		@_updateDebugCanvas()
		@y = 0

	generateNextLine: !->
		if @y >= @mapHeight then return false
		@generateLine(@y)
		@y++
		return true

	generateLine: !(y) ->
		console.log "generating line: #{y}"
		scratchData = @scratchCtx.getImageData(0, y, @mapWidth, 1).data
		for x from 0 til @mapWidth
			red = scratchData[x * 4]
			if red == 255 then
				dataOffset = y * @mapWidth + x
				const N_SAMPLES = 5
				const SAMPLE_JITTER = 1
				height = 0
				for i from 0 til N_SAMPLES
					height += @generatePoint(x + rand(-SAMPLE_JITTER, +SAMPLE_JITTER), y + rand(-SAMPLE_JITTER, SAMPLE_JITTER))
				@heightmapData[dataOffset] = height / N_SAMPLES
		@_updateDebugCanvas()

	_getSegmentDistances: !(x, y) ->
		distances = []
		xy = [x, y]
		for segment of @segments
			[a, b] = segment
			{height} = segment
			closestPt = closestPointOnSegment(xy, segment[0], segment[1])
			distanceSqr = getSquaredDistance(x, y, closestPt[0], closestPt[1])
			distances.push {distance: distanceSqr, pt: closestPt, height}
		distances = distances.sort((a, b) -> (a.distance - b.distance))
		return distances


	generatePoint: !(x, y) ->
		distances = @_getSegmentDistances(x, y)
		ds1 = closestDs = distances[0]
		# higherDs = null
		# lowerDs = null
		for distance of distances
			if distance.height != ds1.height then
				ds2 = distance
				break
		# 	if not lowerDs and distance.height < closestDs.height then
		# 		lowerDs = distance
		# 	if not higherDs and distance.height > closestDs.height then
		# 		higherDs = distance
		# 	if lowerDs and higherDs then break

		# ds2 = lowerDs or higherDs or ds1

		# if lowerDs and higherDs then
		# 	if lowerDs.distance < higherDs.distance then
		# 		ds2 = lowerDs
		# #	else 
		# #		ds2 = higherDs

		# if not ds2 then
		# 	return ds1.height
		#console.log x, y
		#console.log ds1
		#console.log ds2
		ds2 = ds2 or ds1
		pt1 = ds1.pt
		pt2 = ds2.pt
		cpd = closestPointOnSegment([x, y], pt1, pt2)
		interpLength = getDistance(pt1[0], pt1[1], pt2[0], pt2[1])
		[x, y] = cpd
		d1 = getDistance(x, y, pt1[0], pt1[1])
		d2 = getDistance(x, y, pt2[0], pt2[1])
		interpAlpha = d1 / interpLength
		return lerp(ds1.height, ds2.height, interpAlpha)

class IslandGenerator
	@PARAMS = (
		new ParamCollection()
			&group(null, [
				* StringParam("seed", "" + (+new Date()))
				* IntParam("size", 600, 0, 2048)
			])
			&group("Drawing", [
				* BoolParam("isletOutlines", false)
				* BoolParam("contourOutlines", true)
				* BoolParam("bwColorMap", false)
				* IntParam("blurContours", 0, 0, 20)
			])
			&group("Islets", [
				* IntParam("isletMinN", 2)
				* IntParam("isletMaxN", 15)
				* FloatParam("isletSpread", 0.3)
				* FloatParam("isletMinRadius", 0.1)
				* FloatParam("isletMaxRadius", 0.3)
				* IntParam("isletMinPoints", 7)
				* IntParam("isletMaxPoints", 25)
				* FloatParam("isletJagginess", 0.2)
				* BoolParam("isletSeparateRadii", true)
				* FloatParam("isletMinAspect", 0.9, 0, 2)
				* FloatParam("isletMaxAspect", 1.1, 0, 2)
				* FloatParam("isletMinAngle", -0.3, -1, 1)
				* FloatParam("isletMaxAngle", +0.3, -1, 1)
				* FloatParam("isletNegativeChance", 0.05)
			])
			&group("Layers", [
				* IntParam("islandInitialOutset", 0, -15, +15)
				* IntParam("minHeightIncrease", 5)
				* IntParam("maxHeightIncrease", 50)
				* FloatParam("minHeightInsetRatio", 0.9, 0, 2)
				* FloatParam("maxHeightInsetRatio", 1.1, 0, 2)
				* IntParam("minLayerJitter", 2)
				* IntParam("maxLayerJitter", 5)
				* IntParam("layerOffsetSize", 5)
			])
	)

	->
		@params = IslandGenerator.PARAMS.initialize()
		@islets = []
		@layers = []


	generateIslet: (rng) ->
		minMul = 0.5 - @params.isletSpread
		maxMul = 0.5 + @params.isletSpread
		cx = rng.uniform(@width * minMul, @width * maxMul)
		cy = rng.uniform(@height * minMul, @height * maxMul)
		minSize = Math.min(@width, @height)
		maxRadius = rng.uniform(minSize * @params.isletMinRadius, minSize * @params.isletMaxRadius)
		minRadius = maxRadius - maxRadius * @params.isletJagginess
		nPoints = rng.uniformInt(@params.isletMinPoints, @params.isletMaxPoints)
		points = []
		aspect = rng.uniform(@params.isletMinAspect, @params.isletMaxAspect)
		angle = rng.uniform(@params.isletMinAngle, @params.isletMaxAngle) * PI2
		rotate = makeRotator(angle)

		for p from 0 til nPoints
			i = p / nPoints
			xRadius = rng.uniform(minRadius, maxRadius)
			yRadius = rng.uniform(minRadius, maxRadius)
			if not @params.isletSeparateRadii then
				xRadius = yRadius = (xRadius + yRadius) * 0.5
			xRadius /= aspect
			yRadius *= aspect
			[x, y] = rotate(
				Math.cos(i * PI2) * xRadius,
				Math.sin(i * PI2) * yRadius
			)

			points.push [cx + x, cy + y]

		points.negative = (rng.uniform(0, 1) <= @params.isletNegativeChance)

		return points

	convertIsletsToLayers: (rng, islets) ->
		layers = []
		positiveIslets = islets.filter((islet)->!islet.negative)
		negativeIslets = islets.filter((islet)->islet.negative)

		if negativeIslets.length then
			islets = cut(positiveIslets, negativeIslets)

		for isletPoly of merge(islets)
			for layer of outsetPoly(isletPoly, @params.islandInitialOutset)
				layer.height = 0
				layers.push(layer)

		openLayers = [].concat(layers)
		@maxHeight = maxHeight = rng.uniformInt(200, 400)

		while openLayers.length
			layer = openLayers.shift()
			if rng.uniform(0, 1) < 0.05 then # Chance to skip
				console.log "skipping layer"
				continue 
			if layer.height > maxHeight
				console.log "maxheight #{maxHeight} reached"
				break
			heightIncrease = rng.uniformInt(@params.minHeightIncrease, @params.maxHeightIncrease)
			offsetValue = rng.uniform(@params.minHeightInsetRatio, @params.maxHeightInsetRatio) * heightIncrease
			layerJitter = rng.uniform(@params.minLayerJitter, @params.maxLayerJitter)
			
			newLayers = outsetPoly(layer, -offsetValue)
			if newLayers.length
				newLayers = (for newLayer of newLayers
					layerXOffset = rng.uniform(-@params.layerOffsetSize, @params.layerOffsetSize)
					layerYOffset = rng.uniform(-@params.layerOffsetSize, @params.layerOffsetSize)
					newLayer = jitterPoly(rng, newLayer, layerJitter, layerJitter)
					newLayer = offsetPoly(newLayer, layerXOffset, layerYOffset)
					newLayer.height = layer.height + heightIncrease
					newLayer
				)
				openLayers = openLayers.concat(newLayers)
				layers = layers.concat(newLayers)
			else
				console.log "no new layers"

		return layers

	generate: ->
		@width = @height = 0 | (@params.size)
		time = +new Date()
		@rngFarm = new RandomFarm(@params.seed)
		
		isletRng = @rngFarm.get("islet")
		nIslets = isletRng.uniformInt(@params.isletMinN, @params.isletMaxN)
		@islets = islets = (@generateIslet(isletRng) for x from 0 til nIslets)

		layerRng = @rngFarm.get("layer")
		@layers = @convertIsletsToLayers(layerRng, islets)
		return @genTime = ((+new Date()) - time)

	draw: ->
		if not svg = @svg then
			@svg = svg = SVG(document.body)

		svg.size(@width, @height).clear()
		
		
		if @params.bwColorMap then
			svg.rect(@width, @height).fill('#000000')
			colorMap = new Gradient()
				&addPoint '#222222', 0
				&addPoint '#ffffff', 1
		else
			svg.rect(@width, @height).fill('#53BEFF')
			colorMap = new Gradient()
				&addPoint '#94bf8b', 0
				&addPoint '#acd0a5', 0.2
				&addPoint '#bdcc96', 0.5
				&addPoint '#efebc0', 0.8
				&addPoint '#cab982', 0.99
				&addPoint '#cab982', 1.0

		#maxHeight = Math.max.apply(null, (for layers => &height))

		for layer of @layers
			cOffset = layer.height / @maxHeight
			color = colorMap.getColor(cOffset)
			outline = (if layer.height == 0 then 'black' else 'rgba(0,0,0,0.2)')
			poly = svg.polygon(layer).fill(color)
			if @params.contourOutlines
				poly.stroke({width: 1, color: outline})
			if (blur=@params.blurContours)
				poly.filter -> it.gaussianBlur blur
			#poly.node.setAttribute("terr-height", layer.height)
			#poly.node.setAttribute("terr-coff", cOffset)

		if @params.isletOutlines
			for @islets => svg.polygon(&).stroke({width: 1, color: if &negative then 'red' else 'white'}).fill('none')

	regenerateAndDraw: ->
		@generate()
		@draw()
		console.log "generated in #{@genTime} ms"

makeUI = !(ig) ->
	debouncedGenerate = debounce((->ig.regenerateAndDraw()), 50)
	gui = new dat.GUI()
	for group of IslandGenerator.PARAMS.groups
		if group.name
			folder = gui.addFolder(group.name)
		else
			folder = gui
		for param of group.params
			guiParam = null
			if param.type == 'int'
				guiParam = folder.add(ig.params, param.name, param.min, param.max).step(1)
			else if param.type == 'float'
				guiParam = folder.add(ig.params, param.name, param.min, param.max)
			else if param.type == 'bool'
				guiParam = folder.add(ig.params, param.name)
			else if param.type == "string"
				guiParam = folder.add(ig.params, param.name)
			guiParam.onChange(debouncedGenerate)
	ig.gui = gui

makeButton = (text, handler) ->
	button = document.createElement("button")
		&innerHTML = text
		&addEventListener "click", handler, false
		document.body.appendChild &

main = !->
	window.ig = ig = new IslandGenerator("dkkkhurf a der3")
	makeUI(ig)

	ig.regenerateAndDraw()

	generateHeightMap = !->
		hmg = new HeightmapGenerator(ig, 256, 256)
		hmg.startGenerate()
		stepGeneration = !->
			if hmg.generateNextLine() then
				setTimeout(stepGeneration, 1)
		stepGeneration()

		enableWebGL = !->
			th = new HeightmapThreeJS(hmg)
			setInterval((->th.render()), 1000 / 40.0)
			th.updateMesh()

		makeButton("WebGL", enableWebGL)

	makeButton("Generate Heightmap", generateHeightMap)
	document.body.appendChild document.createElement("br")


main()
