const PI2 = Math.PI * 2
const width = 700
const height = 700

class RC4Rand
	(seed) ->
		@s = (for x from 0 til 256 => x)
		@i = @j = 0
		if seed then @mix(seed)
	
	mix: !(seed) ->
		seed = "#seed"
		j = 0
		for i from 0 til @s.length
			ch = seed.charCodeAt(i % seed.length) & 0xFF
			j += @s[i] + ch
			j %= 256
			@_swap(i, j)

	_swap: !(i, j) -> [@s[j], @s[i]] = [@s[i], @s[j]]

	nextByte: !->
		@i = (@i + 1) % 256
		@j = (@j + @s[@i]) % 256
		@_swap(@i, @j)
		return @s[(@s[@i] + @s[@j]) % 256]

	nextFloat: !->
		const BYTES = 7
		output = 0
		for i from 0 til BYTES
			output = output * 256 + @nextByte()
		return output / (Math.pow(2, BYTES * 8) - 1)

	uniform: (a, b) ->
		if b < a then [a, b] = [b, a]
		return a + @nextFloat() * (b - a)
	
	uniformInt: (a, b) -> Math.floor(@uniform(a, b))

class RandomFarm
	(@seed) ->
	get: (name) -> new RC4Rand("#{@seed}+#{name}")


class Gradient
	(@resolution=512) -> @points = []; @bitmap = null
	addPoint: !(color, point) -> @points.push {color, point}
	getColor: !(point) ->
		if not @bitmap then @bitmap = @render() 
		if point < 0 then point = 0
		if point > 1 then point = 1
		offset = (0 | point * @bitmap.width) * 4
		data = @bitmap.data
		return "rgb(#{data[offset]}, #{data[offset+1]}, #{data[offset+2]})"

	render: !->
		canvas = document.createElement("canvas")
		canvas.width = @resolution
		canvas.height = 10
		ctx = canvas.getContext("2d")
		gradient = ctx.createLinearGradient(0, 0, canvas.width, 0)
		for {color, point} of @points
			gradient.addColorStop(point, color)
		ctx.fillStyle = gradient
		ctx.fillRect(0, 0, canvas.width, canvas.height)
		return ctx.getImageData(0, 0, canvas.width, canvas.height)


poly2clipper = (poly) ->
	subj_polygon = new ClipperLib.Polygon()
	for [x, y] of poly
		subj_polygon.push new ClipperLib.IntPoint(x, y)
	return subj_polygon

clipper2poly = (clipper) -> for (clipper || []) => [&X, &Y]

poly_op = (polys1, polys2, clipType) ->
	subj_polygons = new ClipperLib.Polygons()
	for polys1 => subj_polygons.push poly2clipper(&)
	clip_polygons = new ClipperLib.Polygons()
	for polys2 => clip_polygons.push poly2clipper(&)

	clipper = new ClipperLib.Clipper()
	clipper.AddPolygons subj_polygons, ClipperLib.PolyType.ptSubject
	clipper.AddPolygons clip_polygons, ClipperLib.PolyType.ptClip
	solution_polygons = new ClipperLib.Polygons()
	fillType = ClipperLib.PolyFillType.pftPositive
	if not clipper.Execute(clipType, solution_polygons, fillType, fillType) then
		console.log "No success."
		return []
	else
		return (for solution_polygons => clipper2poly(&))

merge = (polys) ->
	polys2 = [].concat(polys)
	polys1 = [polys2.shift()]
	return poly_op(polys1, polys2, ClipperLib.ClipType.ctUnion)

cut = (polys1, polys2) -> poly_op(polys1, polys2, ClipperLib.ClipType.ctDifference)

outsetPoly = (poly, delta) ->
	cpr = new ClipperLib.Clipper()
	joinType = ClipperLib.JoinType.jtMiter
	miterLimit = 0
	offsetPolygons = cpr.OffsetPolygons([poly2clipper(poly)], delta, joinType, miterLimit, true)
	cleanedPolygons = ClipperLib.Clean(offsetPolygons, 2.5)
	return (for cleanedPolygons => clipper2poly(&))

makeRotator = (a) ->
	c = Math.cos(a)
	s = Math.sin(a)
	return (x, y) -> [x * c - y * s, x * s + y * c]


jitterPoly = (rng, poly, ix, iy) -> for [x, y] of poly => [x + rng.uniform(-ix, ix), y + rng.uniform(-iy, iy)]
offsetPoly = (poly, ix, iy) -> for [x, y] of poly => [x + ix, y + iy]

IntParam = (name, value, min=0, max=100) -> {name, value, min, max, type: "int"}
FloatParam = (name, value, min=0, max=1.0) -> {name, value, min, max, type: "float"}
BoolParam = (name, value) -> {name, value: !!value, type: "bool"}
StringParam = (name, value) -> {name, value: "#{value}", type: "string"}

class ParamGroup
	(@name, @params) ->

class ParamCollection
	-> @groups = []
	group: (name, params) -> @groups.push(new ParamGroup(name, params))
	initialize: ->
		params = {}
		for group of @groups
			for param of group.params
				params[param.name] = param.value
		return params


class IslandGenerator
	@PARAMS = (
		new ParamCollection()
			&group(null, [
				* StringParam("seed", "" + (+new Date()))
			])
			&group("Drawing", [
				* BoolParam("isletOutlines", false)
				* BoolParam("contourOutlines", true)
				* BoolParam("bwColorMap", false)
				* IntParam("blurContours", 0, 0, 20)
			])
			&group("Islets", [
				* IntParam("isletMinN", 2)
				* IntParam("isletMaxN", 15)
				* FloatParam("isletSpread", 0.3)
				* FloatParam("isletMinRadius", 0.1)
				* FloatParam("isletMaxRadius", 0.3)
				* IntParam("isletMinPoints", 7)
				* IntParam("isletMaxPoints", 25)
				* FloatParam("isletJagginess", 0.2)
				* BoolParam("isletSeparateRadii", true)
				* FloatParam("isletMinAspect", 0.9, 0, 2)
				* FloatParam("isletMaxAspect", 1.1, 0, 2)
				* FloatParam("isletMinAngle", -0.3, -1, 1)
				* FloatParam("isletMaxAngle", +0.3, -1, 1)
				* FloatParam("isletNegativeChance", 0.05)
			])
			&group("Layers", [
				* IntParam("islandInitialOutset", 0, -15, +15)
				* IntParam("minHeightIncrease", 5)
				* IntParam("maxHeightIncrease", 50)
				* FloatParam("minHeightInsetRatio", 0.9, 0, 2)
				* FloatParam("maxHeightInsetRatio", 1.1, 0, 2)
				* IntParam("minLayerJitter", 2)
				* IntParam("maxLayerJitter", 5)
				* IntParam("layerOffsetSize", 5)
			])
	)

	->
		@params = IslandGenerator.PARAMS.initialize()
		@islets = []
		@layers = []


	generateIslet: (rng) ->
		minMul = 0.5 - @params.isletSpread
		maxMul = 0.5 + @params.isletSpread
		cx = rng.uniform(width * minMul, width * maxMul)
		cy = rng.uniform(height * minMul, height * maxMul)
		maxRadius = rng.uniform(
			Math.min(width, height) * @params.isletMinRadius,
			Math.min(width, height) * @params.isletMaxRadius
		)
		minRadius = maxRadius - maxRadius * @params.isletJagginess
		nPoints = rng.uniformInt(@params.isletMinPoints, @params.isletMaxPoints)
		points = []
		aspect = rng.uniform(@params.isletMinAspect, @params.isletMaxAspect)
		angle = rng.uniform(@params.isletMinAngle, @params.isletMaxAngle) * PI2
		rotate = makeRotator(angle)

		for p from 0 til nPoints
			i = p / nPoints
			xRadius = rng.uniform(minRadius, maxRadius)
			yRadius = rng.uniform(minRadius, maxRadius)
			if not @params.isletSeparateRadii then
				xRadius = yRadius = (xRadius + yRadius) * 0.5
			xRadius /= aspect
			yRadius *= aspect
			[x, y] = rotate(
				Math.cos(i * PI2) * xRadius,
				Math.sin(i * PI2) * yRadius
			)

			points.push [cx + x, cy + y]

		points.negative = (rng.uniform(0, 1) <= @params.isletNegativeChance)

		return points

	convertIsletsToLayers: (rng, islets) ->
		layers = []
		positiveIslets = islets.filter((islet)->!islet.negative)
		negativeIslets = islets.filter((islet)->islet.negative)

		islets = cut(positiveIslets, negativeIslets)

		for isletPoly of merge(islets)
			for layer of outsetPoly(isletPoly, @params.islandInitialOutset)
				layer.height = 0
				layers.push(layer)

		openLayers = [].concat(layers)
		@maxHeight = maxHeight = rng.uniformInt(200, 400)

		while openLayers.length
			layer = openLayers.shift()
			if rng.uniform(0, 1) < 0.05 then # Chance to skip
				console.log "skipping layer"
				continue 
			if layer.height > maxHeight
				console.log "maxheight #{maxHeight} reached"
				break
			heightIncrease = rng.uniformInt(@params.minHeightIncrease, @params.maxHeightIncrease)
			offsetValue = rng.uniform(@params.minHeightInsetRatio, @params.maxHeightInsetRatio) * heightIncrease
			layerJitter = rng.uniform(@params.minLayerJitter, @params.maxLayerJitter)
			
			newLayers = outsetPoly(layer, -offsetValue)
			if newLayers.length
				newLayers = (for newLayer of newLayers
					layerXOffset = rng.uniform(-@params.layerOffsetSize, @params.layerOffsetSize)
					layerYOffset = rng.uniform(-@params.layerOffsetSize, @params.layerOffsetSize)
					newLayer = jitterPoly(rng, newLayer, layerJitter, layerJitter)
					newLayer = offsetPoly(newLayer, layerXOffset, layerYOffset)
					newLayer.height = layer.height + heightIncrease
					newLayer
				)
				openLayers = openLayers.concat(newLayers)
				layers = layers.concat(newLayers)
			else
				console.log "no new layers"

		return layers

	generate: ->
		time = +new Date()
		@rngFarm = new RandomFarm(@params.seed)
		
		isletRng = @rngFarm.get("islet")
		nIslets = isletRng.uniformInt(@params.isletMinN, @params.isletMaxN)
		@islets = islets = (@generateIslet(isletRng) for x from 0 til nIslets)

		layerRng = @rngFarm.get("layer")
		@layers = @convertIsletsToLayers(layerRng, islets)
		return @genTime = ((+new Date()) - time)

	draw: ->
		if not svg = @svg then
			svg = SVG(document.body)
			svg.size(width, height)
			@svg = svg


		svg.clear()
		
		
		if @params.bwColorMap then
			svg.rect(width, height).fill('#000000')
			colorMap = new Gradient()
				&addPoint '#222222', 0
				&addPoint '#ffffff', 1
		else
			svg.rect(width, height).fill('#53BEFF')
			colorMap = new Gradient()
				&addPoint '#94bf8b', 0
				&addPoint '#acd0a5', 0.2
				&addPoint '#bdcc96', 0.5
				&addPoint '#efebc0', 0.8
				&addPoint '#cab982', 0.99
				&addPoint '#cab982', 1.0

		#maxHeight = Math.max.apply(null, (for layers => &height))

		for layer of @layers
			cOffset = layer.height / @maxHeight
			color = colorMap.getColor(cOffset)
			outline = (if layer.height == 0 then 'black' else 'rgba(0,0,0,0.2)')
			poly = svg.polygon(layer).fill(color)
			if @params.contourOutlines
				poly.stroke({width: 1, color: outline})
			if (blur=@params.blurContours)
				poly.filter -> it.gaussianBlur blur
			#poly.node.setAttribute("terr-height", layer.height)
			#poly.node.setAttribute("terr-coff", cOffset)

		if @params.isletOutlines
			for @islets => svg.polygon(&).stroke({width: 1, color: if &negative then 'red' else 'white'}).fill('none')

	regenerateAndDraw: ->
		@generate()
		@draw()
		console.log "generated in #{@genTime} ms"

makeUI = !(ig) ->
	debouncedGenerate = _.debounce((->ig.regenerateAndDraw()), 50)
	gui = new dat.GUI()
	for group of IslandGenerator.PARAMS.groups
		if group.name
			folder = gui.addFolder(group.name)
		else
			folder = gui
		for param of group.params
			guiParam = null
			if param.type == 'int'
				guiParam = folder.add(ig.params, param.name, param.min, param.max).step(1)
			else if param.type == 'float'
				guiParam = folder.add(ig.params, param.name, param.min, param.max)
			else if param.type == 'bool'
				guiParam = folder.add(ig.params, param.name)
			else if param.type == "string"
				guiParam = folder.add(ig.params, param.name)
			guiParam.onChange(debouncedGenerate)
			
	ig.gui = gui

main = !->
	window.ig = ig = new IslandGenerator("dkkkhurf a der3")
	makeUI(ig)

	ig.regenerateAndDraw()

main()