const PI2 = Math.PI * 2
const width = 700
const height = 700

class RC4Rand
	(seed) ->
		@s = (for x from 0 til 256 => x)
		@i = @j = 0
		if seed then @mix(seed)
	
	mix: !(seed) ->
		seed = "#seed"
		j = 0
		for i from 0 til @s.length
			ch = seed.charCodeAt(i % seed.length) & 0xFF
			j += @s[i] + ch
			j %= 256
			@_swap(i, j)

	_swap: !(i, j) -> [@s[j], @s[i]] = [@s[i], @s[j]]

	nextByte: ->
		@i = (@i + 1) % 256
		@j = (@j + @s[@i]) % 256
		@_swap(@i, @j)
		return @s[(@s[@i] + @s[@j]) % 256]

	nextFloat: !->
		const BYTES = 7
		output = 0
		for i from 0 til BYTES
			output = output * 256 + @nextByte()
		return output / (Math.pow(2, BYTES * 8) - 1)

	uniform: (a, b) -> a + @nextFloat() * (b - a)
	uniformInt: (a, b) -> Math.floor(a + @nextFloat() * (b - a))

class Gradient
	(@resolution=512) -> @points = []; @bitmap = null
	addPoint: !(color, point) -> @points.push {color, point}
	getColor: !(point) ->
		if not @bitmap then @bitmap = @render() 
		if point < 0 then point = 0
		if point > 1 then point = 1
		offset = (0 | point * @bitmap.width) * 4
		data = @bitmap.data
		return "rgb(#{data[offset]}, #{data[offset+1]}, #{data[offset+2]})"

	render: !->
		canvas = document.createElement("canvas")
		canvas.width = @resolution
		canvas.height = 10
		ctx = canvas.getContext("2d")
		gradient = ctx.createLinearGradient(0, 0, canvas.width, 0)
		for {color, point} of @points
			gradient.addColorStop(point, color)
		ctx.fillStyle = gradient
		ctx.fillRect(0, 0, canvas.width, canvas.height)
		return ctx.getImageData(0, 0, canvas.width, canvas.height)


poly2clipper = (poly) ->
	subj_polygon = new ClipperLib.Polygon()
	for [x, y] of poly
		subj_polygon.push new ClipperLib.IntPoint(x, y)
	return subj_polygon

clipper2poly = (clipper) -> for (clipper || []) => [&X, &Y]

merge = (polys) ->
	polys = [].concat(polys)
	subj_polygons = new ClipperLib.Polygons()
	subj_polygons.push poly2clipper(polys.shift())
	clip_polygons = new ClipperLib.Polygons()
	while polys.length => clip_polygons.push poly2clipper(polys.shift())
	clipper = new ClipperLib.Clipper()
	clipper.AddPolygons subj_polygons, ClipperLib.PolyType.ptSubject
	clipper.AddPolygons clip_polygons, ClipperLib.PolyType.ptClip
	solution_polygons = new ClipperLib.Polygons()
	clipType = ClipperLib.ClipType.ctUnion
	fillType = ClipperLib.PolyFillType.pftPositive
	if not clipper.Execute(clipType, solution_polygons, fillType, fillType) then
		console.log "No success."
		return []
	else
		return (for solution_polygons => clipper2poly(&))

outsetPoly = (poly, delta) ->
	cpr = new ClipperLib.Clipper()
	joinType = ClipperLib.JoinType.jtMiter
	miterLimit = 0
	offsetPolygons = cpr.OffsetPolygons([poly2clipper(poly)], delta, joinType, miterLimit, true)
	cleanedPolygons = ClipperLib.Clean(offsetPolygons, 2.5)
	return (for cleanedPolygons => clipper2poly(&))
	

jitterPoly = (rng, poly, ix, iy) -> for [x, y] of poly => [x + rng.uniform(-ix, ix), y + rng.uniform(-iy, iy)]
offsetPoly = (poly, ix, iy) -> for [x, y] of poly => [x + ix, y + iy]

IntParam = (name, value, min=0, max=100) -> {name, value, min, max, type: "int"}
FloatParam = (name, value, min=0, max=1) -> {name, value, min, max, type: "float"}
BoolParam = (name, value) -> {name, value: !!value, type: "bool"}
StringParam = (name, value) -> {name, value: "#{value}", type: "string"}

class IslandGenerator
	@PARAMS = [

		* StringParam("seed", "jk43jkcm")
		* BoolParam("debug", false)
		* IntParam("isletMinN", 2)
		* IntParam("isletMaxN", 15)
		* FloatParam("isletSpread", 0.3)
		* FloatParam("isletMinRadius", 0.1)
		* FloatParam("isletMaxRadius", 0.3)
		* IntParam("isletMinPoints", 7)
		* IntParam("isletMaxPoints", 25)
		* FloatParam("isletJagginess", 0.2)
		* BoolParam("isletSeparateRadii", true)

		* IntParam("islandInitialOutset", 0, -15, +15)
		* IntParam("minHeightIncrease", 5)
		* IntParam("maxHeightIncrease", 50)
		* FloatParam("minHeightInsetRatio", 0.9, 0, 2)
		* FloatParam("maxHeightInsetRatio", 1.1, 0, 2)
		* IntParam("minLayerJitter", 2)
		* IntParam("maxLayerJitter", 5)
		* IntParam("layerOffsetSize", 5)
	]

	->
		@params = {}
		for param of IslandGenerator.PARAMS
			@params[param.name] = param.value
		@islets = []
		@layers = []


	generateIslet: ->
		minMul = 0.5 - @params.isletSpread
		maxMul = 0.5 + @params.isletSpread
		cx = @rng.uniform(width * minMul, width * maxMul)
		cy = @rng.uniform(height * minMul, height * maxMul)
		maxRadius = @rng.uniform(
			Math.min(width, height) * @params.isletMinRadius,
			Math.min(width, height) * @params.isletMaxRadius
		)
		minRadius = maxRadius - maxRadius * @params.isletJagginess
		nPoints = @rng.uniformInt(@params.isletMinPoints, @params.isletMaxPoints)
		points = []

		for p from 0 til nPoints
			i = p / nPoints
			xRadius = @rng.uniform(minRadius, maxRadius)
			yRadius = @rng.uniform(minRadius, maxRadius)
			if not @params.isletSeparateRadii then
				xRadius = yRadius = (xRadius + yRadius) * 0.5
			x = cx + Math.cos(i * PI2) * xRadius
			y = cy + Math.sin(i * PI2) * yRadius
			points.push [x, y]

		return points


	generate: ->
		@rng = rng = new RC4Rand(@params.seed)

		nIslets = @rng.uniformInt(@params.isletMinN, @params.isletMaxN)
		@islets = islets = (@generateIslet() for x from 0 til nIslets)

		layers = []
		for isletPoly of merge(islets)
			for layer of outsetPoly(isletPoly, @params.islandInitialOutset)
				layer.height = 0
				layers.push(layer)

		openLayers = [].concat(layers)
		@maxHeight = maxHeight = @rng.uniformInt(200, 400)

		while openLayers.length
			layer = openLayers.shift()
			if @rng.uniform(0, 1) < 0.05 then # Chance to skip
				console.log "skipping layer"
				continue 
			if layer.height > maxHeight
				console.log "maxheight #{maxHeight} reached"
				break
			heightIncrease = @rng.uniformInt(@params.minHeightIncrease, @params.maxHeightIncrease)
			offsetValue = @rng.uniform(@params.minHeightInsetRatio, @params.maxHeightInsetRatio) * heightIncrease
			layerJitter = @rng.uniformInt(@params.minLayerJitter, @params.maxLayerJitter)
			layerXOffset = @rng.uniformInt(-@params.layerOffsetSize, @params.layerOffsetSize)
			layerYOffset = @rng.uniformInt(-@params.layerOffsetSize, @params.layerOffsetSize)
			
			newLayers = outsetPoly(layer, -offsetValue)
			if newLayers.length
				newLayers = (for newLayers => offsetPoly(jitterPoly(@rng, &, layerJitter, layerJitter), layerXOffset, layerYOffset))
				for newLayers => &height = layer.height + heightIncrease
				openLayers = openLayers.concat(newLayers)
				layers = layers.concat(newLayers)
			else
				console.log "no new layers"

		@layers = layers

	draw: ->
		if not svg = @svg then
			svg = SVG(document.body)
			svg.size(width, height)
			@svg = svg


		svg.clear()
		svg.rect(width, height).fill('#53BEFF')
		

		topoColorMap = new Gradient()
			&addPoint '#acd0a5', 0
			&addPoint '#94bf8b', 0.2
			&addPoint '#bdcc96', 0.5
			&addPoint '#efebc0', 0.8
			&addPoint '#cab982', 0.99
			&addPoint '#cab982', 1.0

		bwColorMap = new Gradient()
			&addPoint 'black', 0
			&addPoint 'white', 1

		colorMap = topoColorMap


		#maxHeight = Math.max.apply(null, (for layers => &height))

		for layer of @layers
			cOffset = layer.height / @maxHeight
			color = colorMap.getColor(cOffset)
			outline = (if layer.height == 0 then 'black' else 'rgba(0,0,0,0.2)')
			poly = svg.polygon(layer).stroke({width: 1, color: outline}).fill(color)
			poly.node.setAttribute("terr-height", layer.height)
			poly.node.setAttribute("terr-coff", cOffset)

		if @params.debug
			for @islets => svg.polygon(&).stroke({width: 1, color: 'red'}).fill('none')

	regenerateAndDraw: ->
		@generate()
		@draw()

makeUI = !(ig) ->
	debouncedGenerate = _.debounce((->ig.regenerateAndDraw()), 50)
	gui = new dat.GUI()
	for param of IslandGenerator.PARAMS
		guiParam = null
		if param.type == 'int'
			guiParam = gui.add(ig.params, param.name, param.min, param.max).step(1)
		else if param.type == 'float'
			guiParam = gui.add(ig.params, param.name, param.min, param.max)
		else if param.type == 'bool'
			guiParam = gui.add(ig.params, param.name)
		else if param.type == "string"
			guiParam = gui.add(ig.params, param.name)
		guiParam.onChange(debouncedGenerate)
			
	ig.gui = gui

main = !->
	window.ig = ig = new IslandGenerator("dkkkhurf a der3")
	makeUI(ig)

	ig.regenerateAndDraw()

main()